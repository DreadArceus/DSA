----Pair
> pair<data_type, data_type> [name] = {Data 1, Data 2};

  first and second member variables are the respective data.

----Vector(dynamic memory version of an array)
> vector<data_type> [name]; (initialises a null vector)

  push_back(), emplace_back(), back(), erase(), insert(),
  pop_back(), size(), clear(), swap(), empty():
    explained in "STL.cpp"
  begin(), rbegin(), cbegin(), end(), rend(), cend():
    return iterators, explained in "STL.cpp"
  at():
    works same as v[x], hence never used because of the increased typing

----Iterator
> data_structure::iterator [name]; (initialises a null iterator)

  increment and decrement operators are overloaded to go forward and backwards
    in the (memory addresses of) elements of the data structure.

----List
> list<data_type> [name]; (initialises a null list)

  Stores all the elements in random memory addresses and links to the next with pointers
  Therefore can only be iterated through with iterators (ie no indexing)
  All the member functions of vectors and,
  push_front(), pop_front(), emplace_front(), front():
    The starting versions of the respective back functions.

----Deque
> deque<data_type> [name]; (initialises empty deque)

  Stores elements in adjacent addressed segments of memory.
  All the member functions of List.
**See vector vs list vs deque for time complexity analysis.

----Stack
> stack<data_type> [name]; (initialises empty stack)

  Last in - First out
  push(), emplace(), top(), pop(), size(), swap(), empty():
    explained in "STL.cpp"

----Queues
> queue<data_type> [name]; (initialises empty queue)

  First in - First Out (works like an IRL queue)
  push(), emplace(), front(), back(), pop(), size(), swap(), empty():
    explained in "STL.cpp"

----Priority Queues
> priority_queue<data_type> [name]; (initialises empty, descending sorting, PQ)

  push(), emplace():
    explained in "STL.cpp"
  All the other member functions are same as Stack.

----Set
> set<data_type> [name]; (initialises empty set)

  Only stores unique elements, automatic ascending sorting.
  Iterator returner member functions and swap(), empty(), size() are all the same as vector.
  insert() [also emplace()]:
    can be used like the insert function of vectors but by default,
    it enables the auto ascending sort in a set.
  find(), erase(), count(), upper_bound(), lower_bound():
    explained in "STL.cpp"

----Multiset
> multiset<data_type> [name]; (initialises empty multiset)

  Set except also stores duplicates.
  erase() changes a bit (see "STL.cpp")
  All other member functions are the same as set.

----Unordered_Set
> unordered_set<data_type> [name]; (initialises empty unordered_set)

  Set but with no sorting, makes find() [and erase()] faster.
  All the member functions are the same as set, exception explained in "STL.cpp"

----Map
> map<data_type, data_type> [name]; (initialises an empty map)

  A map has a key and a value for each entry, whose data types are declared upon initialisation.
  find(), insert(), emplace():
    explained in "STL.cpp"
  All other member functions like everything else.

----Multimap
> multimap<data_type, data_type> [name]; (initialises an empty multimap)

  Map except can store multiple entries with the same key.
  Cannot use the key as an index, as a result.
  All other member functions same as map.

----Unordered_Map
> unordered_map<data_type, data_type> [name]; (initialises an empty unordered_map)

  Map except no sorting, similar timing advantage over map as unordered_set over set.
  All other member functions same as map.

----Other Things
  sort(), __builtin_popcount(), next_permutation(), max_element():
    explained in "STL.cpp"

~~The End~~
